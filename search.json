[
  {
    "objectID": "reference/rl_sop_bp_bootstrap.html",
    "href": "reference/rl_sop_bp_bootstrap.html",
    "title": "rl_sop_bp_bootstrap",
    "section": "",
    "text": "rl_sop_bp_bootstrap\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bp_bootstrap(p_array::Array{T,3}, lam, cl, reps_range, chart_choice, ) where {T&lt;:Real}\n\nCompute the EWMA-BP-SOP run length for a given control limit using bootstraping.\nThe input parameters are:\n\np_array::Array{Float64,3}: A 3D array with the with the relative frequencies for each d1-d2 (delay) combination. The first dimension (rows) is the picture, the second dimension refers to the patterns group (s₁, s₂, or s₃) and the third dimension denotes each d₁-d₂ combination. This array will be used for re-sampling.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4."
  },
  {
    "objectID": "reference/SQINMA11.html",
    "href": "reference/SQINMA11.html",
    "title": "SQINMA11",
    "section": "",
    "text": "SQINMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSQINMA11(dgp_params, eps_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a Spatial quadratic integer moving-average SQINMA(1, 1):\n\\(\\qquad X_{t_1, t_2}=\\beta_1 \\circ \\epsilon_{t_1-1, t_2}^a+\\beta_2 \\circ \\epsilon_{t_1, t_2-1}^b+\\beta_3 \\circ \\epsilon_{t_1-1, t_2-1}^c+\\epsilon_{t_1, t_2}.\\)\nXₜ₁,ₜ₂ = β₁ ⋅ εₜ₁₋₁,ₜ₂ᵃ + β₂ ⋅ εₜ₁,ₜ₂₋₁ᵇ + β₃ ⋅ εₜ₁₋₁,ₜ₂₋₁ᶜ + εₜ₁,ₜ₂\n\ndgp_params::Tuple(β₁::Float64, β₂::Float64, β₃::Float64). Note that β₁, β₂, and β₃ ∈ [0, 1].\neps_params::Tuple(a::Int, b::Int, c::Int). A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nM_rows::Int. The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nN_cols::Int. The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\ndist::Distribution A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Nothing.\nprerun::Int A value to initialize the DGP to achieve stationarity. These number of rows and columns will be discarded after the initialization.\n\n\nsqinma11 = SQINMA11((0.5, 0.3, 0.2), (1, 1, 2), 10, 10, Normal(0, 1), nothing, 1)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SQINMA11"
    ]
  },
  {
    "objectID": "reference/dependence_op.html",
    "href": "reference/dependence_op.html",
    "title": "dependence_op",
    "section": "",
    "text": "dependence_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ndependence_op(tsx, tsy; op_length::Int=3, d=1)\n\nCompute the ordinal pattern dependence coefficient by Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706."
  },
  {
    "objectID": "reference/BSQMA11.html",
    "href": "reference/BSQMA11.html",
    "title": "BSQMA11",
    "section": "",
    "text": "BSQMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBSQMA11(dgp_params, eps_params, M_rows, N_cols, dist, dist_ao)\n\nA struct to define a bilateral spatial quadratic moving-average (BSQMA(1, 1)) process:\nY{t1, t2}=b1 ^a+b2 ^b+b3 ^c+b*4 ^d+,\nYₜ₁,ₜ₂ = b₁ ⋅ εₜ₁₋₁,ₜ₂₋₁ᵃ + b₂ ⋅ εₜ₁₊₁,ₜ₂₋₁ᵇ + b₃ ⋅ εₜ₁₊₁,ₜ₂₊₁ᶜ + b₄ ⋅ εₜ₁₋₁,ₜ₂₊₁ᵈ + εₜ₁,ₜ₂\n\ndgp_params::Tuple{Float64, Float64, Float64, Float64}: A tuple of the parameters of the DGP. The parameters correspond to b₁, b₂, b₃ and b₄, respectively.\neps_params::Tuple{Int, Int, Int, Int}: A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nM_rows::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nN_cols::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\ndist::Distribution: A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Nothing: Nothing.\n\n\nbsqma11 = BSQMA11((0.5, 0.3, 0.2, 0.1), (1, 1, 2, 2), 10, 10, Normal(0, 1), nothing)"
  },
  {
    "objectID": "reference/rl_sop_bp.html",
    "href": "reference/rl_sop_bp.html",
    "title": "rl_sop_bp",
    "section": "",
    "text": "rl_sop_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bp(\n\nlam, cl, lookuparraysop, spatialdgp::ICSP, repsrange, dist, chartchoice, d1vec::Vector{Int}, d2_vec::Vector{Int} )\nComputes the run length for a given in-control spatial DGP, using the EWMA-BP-SOP statistic.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\nspatial_dgp::ICSP: A struct for the in-control spatial DGP.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\ndist::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nd1_vec::Vector{Int}: A vector with integer values for the first delay (d₁).\nd2_vec::Vector{Int}: A vector with integer values for the second delay (d₂).\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bp(\n\nlam, cl, lookuparraysop, preps, spatialdgp::SpatialDGP, disterror::UnivariateDistribution, distao::Union{Nothing,UnivariateDistribution}, chartchoice, d1vec::Vector{Int}, d2_vec::Vector{Int} )\nComputes the run length for a given out-of-control DGP, using the EWMA-BP-SOP statistic.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\np_reps::UnitRange{Int}: A range of integers for the number of repetitions.\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\ndist_error::UnivariateDistribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing,UnivariateDistribution}: A distribution for the additive outlier.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nd1_vec::Vector{Int}: A vector with integer values for the first delay (d₁).\nd2_vec::Vector{Int}: A vector with integer values for the second delay (d₂)."
  },
  {
    "objectID": "reference/arl_sacf_ic.html",
    "href": "reference/arl_sacf_ic.html",
    "title": "arl_sacf_ic",
    "section": "",
    "text": "arl_sacf_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\narlsacfic(lam, cl, spatialdgp::ICSTS, d1::Int, d2::Int, reps=10000)\nCompute the in-control average run length (ARL), using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination. The function returns the ARL for a given control limit cl and a given number of repetitions reps.\nThe input arguments are:\n\nspatial_dgp: The in-control spatial data generating process (DGP) to use for the SACF function.\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\nreps: The number of repetitions to compute the ARL."
  },
  {
    "objectID": "reference/rl_sop_bootstrap.html",
    "href": "reference/rl_sop_bootstrap.html",
    "title": "rl_sop_bootstrap",
    "section": "",
    "text": "rl_sop_bootstrap\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bootstrap(lam, cl, reps_range, chart_choice, p_mat::Array{Float64,2})\n\nCompute the run length for a given control limit using bootstraping instead of a theoretical in-control distribution.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions. This has to be a range to be compatible with arl_sop() which uses threading and multi-processing.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\np_mat::Array{Float64,2}: A matrix with the values of the relative frequencies of each d1-d2 (delay) combination. This matrix will be used for re-sampling."
  },
  {
    "objectID": "reference/arl_sacf_bp_oc.html",
    "href": "reference/arl_sacf_bp_oc.html",
    "title": "arl_sacf_bp_oc",
    "section": "",
    "text": "arl_sacf_bp_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf_bp_oc(spatial_dgp::SpatialDGP, lam, cl, w::Int, reps=10_000)\n\nCompute the out-of-control average run length (ARL) using the spatial autocorrelation function (SACF) for the BP-statistic. The function returns the ARL for a given control limit cl and a given number of repetitions reps. The input arguments are:\n\nspatial_dgp::SpatialDGP: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11.\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1_vec::Vector{Int}: The first (row) delays for the spatial process.\nd2_vec::Vector{Int}: The second (column) delays for the spatial process.\nreps: The number of repetitions to compute the ARL."
  },
  {
    "objectID": "reference/cl_sop.html",
    "href": "reference/cl_sop.html",
    "title": "cl_sop",
    "section": "",
    "text": "cl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sop(\n\nsopdgp::ICSTS, lam, L0, clinit, d1::Int, d2::Int, reps=10000; chartchoice=3, jmin=4, jmax=6, verbose=false )\nCompute the control limit for a given in-control process. The input parameters are:\n\nsop_dgp: The in-control spatial process (ICSTS) to use for the control limit.\nlam::Float64: A scalar value for lambda for the EWMA chart.\nL0::Float64: The desired average run length.\ncl_init::Float64: The initial value for the control limit.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\nreps::Int: The number of replications to compute the ARL.\nchart_choice::Int: The chart choice for the SOP chart.\njmin: The minimum number of values to change after the decimal point in the control limit.\njmax: The maximum number of values to change after the decimal point in the control limit.\nverbose::Bool: A boolean to indicate whether to print the control limit and ARL for each iteration."
  },
  {
    "objectID": "reference/compute_p_mat.html",
    "href": "reference/compute_p_mat.html",
    "title": "compute_p_mat",
    "section": "",
    "text": "compute_p_mat\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompute_p_mat(data::Array{Float64,3})\n\nCompute the matrix of p-hat values for a given 3D array of data. These values are used for bootstrapping."
  },
  {
    "objectID": "reference/cl_sop_bootstrap.html",
    "href": "reference/cl_sop_bootstrap.html",
    "title": "cl_sop_bootstrap",
    "section": "",
    "text": "cl_sop_bootstrap\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sop_bootstrap(\n\ndata::Array{T,3}, lam, L0, clinit, d1, d2, reps=10000; chart_choice=3, jmin=3, jmax=7, verbose=false )\nCompute the SOP control limit for the EWMA-chart based on bootstraping. The function returns the control limit for a given average run.\nThe input parameters are:\n\ndata::Array{T,3}: A 3D-array containing the data for the EWMA-chart.\nlam::Real: The smoothing parameter for the EWMA-chart.\nL0::Real: The average run length for the EWMA-chart.\ncl_init::Real: The initial value for the control limit.\nd1::Int: The first dimension of the data array.\nd2::Int: The second dimension of the data array.\nreps::Int=10_000: The number of bootstrap replications.\nchart_choice::Int: The choice of the chart for the EWMA-chart. The default is 3.\njmin: The minimum number of values to change after the decimal point in the control limit.\njmax: The maximum number of values to change after the decimal point in the control limit.\nverbose::Bool: A boolean to indicate whether to print the control limit and ARL for each iteration."
  },
  {
    "objectID": "reference/rl_sop_oc.html",
    "href": "reference/rl_sop_oc.html",
    "title": "rl_sop_oc",
    "section": "",
    "text": "rl_sop_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_oc(\n\nspatialdgp::SpatialDGP, lam, cl, lookuparraysop, preps::UnitRange{Int}, disterror::UnivariateDistribution, distao::Union{Nothing,UnivariateDistribution}, chart_choice, m, n, d1::Int, d2::Int )\nComputes the run length for a given out-of-control DGP. The input parameters are:\n\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\np_reps::UnitRange{Int}: A range of integers for the number of repetitions.\ndist_error::UnivariateDistribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing,UnivariateDistribution}: A distribution for the additive outlier.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nm::Int: An integer value for the number of rows for the final “SOP” matrix.\nn::Int: An integer value for the number of columns for the final “SOP” matrix.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂)."
  },
  {
    "objectID": "reference/cl_op.html",
    "href": "reference/cl_op.html",
    "title": "cl_op",
    "section": "",
    "text": "cl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_op(lam, L0, op_dgp, cl_init, reps=10000; chart_choice, jmin=4, jmax=6, verbose=false, d=1, ced=false, ad=100)\n\nFunction to compute the control limit for ordinal patterns.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\nL0::Float64: In-control ARL.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1}: DGP.\ncl_init::Float64: Initial guess for the control limit.\nreps::Int64: Number of replications.\nchart_choice::Int\n\n\\(\\widehat{H}^{(d)}=-\\sum_{k=1}^{m!} \\hat{p}_k{ }^{(d)} \\ln \\hat{p}_k{ }^{(d)}\\)\n\\(\\widehat{H}_{\\mathrm{ex}}^{(d)}=-\\sum_{k=1}^{m!}\\left(1-\\hat{p}_k{ }^{(d)}\\right) \\ln \\left(1-\\hat{p}_k{ }^{(d)}\\right)\\)\n\\(\\widehat{\\Delta}^{(d)}=\\sum_{k=1}^{m!}\\left(\\hat{p}_k^{(d)}-1 / m!\\right)^2\\)\n\\(\\hat{\\beta}^{(d)}=\\hat{p}_6^{(d)}-\\hat{p}_1^{(d)}\\)\n\\(\\hat{\\tau}^{(d)}=\\hat{p}_6^{(d)}+\\hat{p}_1^{(d)}-\\frac{1}{3}\\)\n\\(\\hat{\\delta}^{(d)}=\\hat{p}_4^{(d)}+\\hat{p}_5^{(d)}-\\hat{p}_3^{(d)}-\\hat{p}_2^{(d)}\\)\n\nThe patterns are categorized as follows:\n\\(\\qquad p_1 = (3,2,1);  \\quad p_2=(3,1,2);  \\quad p_3 = (2,3,1);\\)\n\\(\\qquad p_4 = (1,3,2);  \\quad p_5 = (2,1,3);  \\quad p_ 6 = (1,2,3)\\)\njmin::Int Minimum number of decimals for final control limit to optimize.\njmax::Int Maximum number of decimals for final control limit to optimize.\nverbose::Bool=false Print intermediate results?\nd::Union{Int,Vector{Int}}=1: Delay vector.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.",
    "crumbs": [
      "API",
      "Functions for ordinal patterns",
      "cl_op"
    ]
  },
  {
    "objectID": "reference/arl_acf.html",
    "href": "reference/arl_acf.html",
    "title": "arl_acf",
    "section": "",
    "text": "arl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_acf(lam, cl, acf_dgp, reps=10000)\n\nFunction to compute the average run length (ARL) for a specified DGP using the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\ncl::Float64: Control limit for the ACF statistic.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\nreps::Int64: Number of replications.\n\n\narl_acf(0.1, 3.0, IC(Normal(0, 1)), 10000)"
  },
  {
    "objectID": "reference/SAR1.html",
    "href": "reference/SAR1.html",
    "title": "SAR1",
    "section": "",
    "text": "SAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSAR1(dgp_params, M_rows, N_cols, dist, dist_ao, margin)\n\nA struct to define a first-order simultaneous autoregressive (SAR(1)) model:\n\\(\\qquad Y_{t_1, t_2}=a_1 \\cdot Y_{t_1-1, t_2}+a_2 \\cdot Y_{t_1, t_2-1}+a_3 \\cdot Y_{t_1, t_2+1}+a_4 \\cdot Y_{t_1+1, t_2}+\\varepsilon_{t_1, t_2}.\\)\nYₜ₁,ₜ₂ = a₁ ⋅ Yₜ₁₋₁,ₜ₂ + a₂ ⋅ Yₜ₁,ₜ₂₋₁ + a₃ ⋅ Yₜ₁,ₜ₂₊₁ + a₄ ⋅ Yₜ₁₊₁,ₜ₂ + εₜ₁,ₜ₂\n\ndgp_params::Tuple{a₁::Float64, a₂::Float64, Float64, Float64}: A tuple of the parameters of the DGP. The first element is the parameter a₁, the second element is the parameter a₂, and the third element is the parameter a₃. a₄.\nM_rows::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nN_cols::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\ndist::Distribution: A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing, Distribution}: Nothing or a distribution for additive outliers. For additive outliers you can use any univariate distribution from the Distributions.jl package.\nmargin::Int: The margin for the spatial matrix used for initialization.\n\n\nsar1 = SAR1((0.5, 0.3, 0.2, 0.1), 10, 10, Normal(0, 1), nothing, 20)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SAR1"
    ]
  },
  {
    "objectID": "reference/rl_sop_ic.html",
    "href": "reference/rl_sop_ic.html",
    "title": "rl_sop_ic",
    "section": "",
    "text": "rl_sop_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_ic(lam, cl, lookup_array_sop, reps_range, dist, chart_choice, m, n, d1::Int, d2::Int)\n\nCompute the run length for a given in-control spatial DGP.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\ndist::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nm::Int: An integer value for the number of rows for the final “SOP” matrix.\nn::Int: An integer value for the number of columns for the final “SOP” matrix.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂)."
  },
  {
    "objectID": "reference/sacf.html",
    "href": "reference/sacf.html",
    "title": "sacf",
    "section": "",
    "text": "sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsacf(X_centered, d1::Int, d2::Int)\n\n\nX_centered: The centered (de-meaned) data matrix.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process."
  },
  {
    "objectID": "reference/rl_sacf_oc.html",
    "href": "reference/rl_sacf_oc.html",
    "title": "rl_sacf_oc",
    "section": "",
    "text": "rl_sacf_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf_oc(\n\nspatialdgp::SpatialDGP, lam, cl, d1::Int, d2::Int, preps::UnitRange, disterror::UnivariateDistribution, distao::Union{UnivariateDistribution,Nothing} )\nCompute the out-of-control run length using the spatial autocorrelation function (SACF). The function returns the run length for a given control limit cl and a given number of repetitions reps.\nThe input arguments are:\n\nspatial_dgp::SpatialDGP: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11.\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\np_reps::UnitRange: The number of repetitions to compute the run length. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf()."
  },
  {
    "objectID": "reference/cl_sop_bp.html",
    "href": "reference/cl_sop_bp.html",
    "title": "cl_sop_bp",
    "section": "",
    "text": "cl_sop_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sop_bp(\n\nspdgp::ICSP, lam, L0, clinit, w, reps=10000; chartchoice=3, jmin=4, jmax=6, verbose=false )\nCompute the control limit for the EWMA-chart for the BP-statistic. The function returns the control limit for a given average run. The input parameters are:\n\nsp_dgp::ICSTS: The in-control spatial process (ICSTS).\nlam::Float64: A scalar value for lambda for the EWMA chart.\nL0::Float64: The desired average run length.\ncl_init::Float64: The initial value for the control limit.\nw::Int: The window size for the BP-statistic.\nreps::Int: The number of replications to compute the ARL.\nchart_choice::Int: The chart choice for the SOP chart.\njmin: The minimum number of values to change after the decimal point in the control limit.\njmax: The maximum number of values to change after the decimal point in the control limit.\nverbose::Bool: A boolean to indicate whether to print the control limit and ARL for each iteration."
  },
  {
    "objectID": "reference/arl_sacf_bp_ic.html",
    "href": "reference/arl_sacf_bp_ic.html",
    "title": "arl_sacf_bp_ic",
    "section": "",
    "text": "arl_sacf_bp_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf_bp_ic(lam, cl, sp_dgp::ICSP, d1_vec::Vector{Int}, d2_vec::Vector{Int}, reps=10_000)\n\nCompute the in-control average run length (ARL) using the spatial autocorrelation function (SACF) for the BP-statistic. The input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nsp_dgp: The in-control spatial data generating process (DGP) to use for the SACF function.\nd1_vec::Vector{Int}: The first (row) delays for the spatial process.\nd2_vec::Vector{Int}: The second (column) delays for the spatial process.\nreps: The number of repetitions to compute the ARL."
  },
  {
    "objectID": "reference/PoiBin.html",
    "href": "reference/PoiBin.html",
    "title": "PoiBin",
    "section": "",
    "text": "PoiBin\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nPoiBin{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a Poisson-Binomial distribution.\n#| eval: false\ndist = PoiBin(0.5, 5)\nrand(dist)"
  },
  {
    "objectID": "reference/arl_sop_bp_bootstrap.html",
    "href": "reference/arl_sop_bp_bootstrap.html",
    "title": "arl_sop_bp_bootstrap",
    "section": "",
    "text": "arl_sop_bp_bootstrap\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop_bp(\n    p_array::Array{T,3}, lam, cl, w, reps; chart_choice=3\n) where {T&lt;:Real}\n\nCompute the average run length for the BP-EWMA-SOP for a given control limit using bootstraping\nThe input parameters are:\n\np_array::Array{Float64, 3}: A 3D array with the with the relative frequencies of each d1-d2 (delay) combination. The first dimension (rows) is the picture, the second dimension refers to the patterns group (s₁, s₂, or s₃) and the third dimension denotes each d₁-d₂ combination. This matrix will be used for re-sampling.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nw::Int: An integer value for the number of workers.\nreps::Int: An integer value for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4."
  },
  {
    "objectID": "reference/rl_acf.html",
    "href": "reference/rl_acf.html",
    "title": "rl_acf",
    "section": "",
    "text": "rl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_acf(lam, cl, p_reps, acf_dgp)\n\nFunction to compute the run length (RL) for a specified DGP using the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\ncl::Float64: Control limit for the ACF statistic.\np_reps::Vector{Int64}: Unit range for number of replications.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\n\n\nrl_acf(0.1, 3.0, 10_000, IC(Normal(0, 1)))"
  },
  {
    "objectID": "reference/arl_sop_bp_ic.html",
    "href": "reference/arl_sop_bp_ic.html",
    "title": "arl_sop_bp_ic",
    "section": "",
    "text": "arl_sop_bp_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop_bp_ic(\n\nspatialdgp::ICSP, lam, cl, w::Int, reps=10000; chart_choice=3 )\nComputes the average run length (ARL) for a given in-control spatial DGP, using EWMA-BP-SOP statistics.\nThe input parameters are:\n\nspatial_dgp::ICSP: A struct for the in-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nw::Int: An integer value for the window size for the BP-statistic.\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4."
  },
  {
    "objectID": "reference/rl_op.html",
    "href": "reference/rl_op.html",
    "title": "rl_op",
    "section": "",
    "text": "rl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_op(lam, cl, lookup_array_op, p_reps, op_dgp,\n  op_dgp_dist, chart_choice; d::Union{Int,Vector{Int}}=1, ced=false, ad=100)\n\nFunction to compute run length for ordinal patterns.\n\nlam::Float64: Smoothing parameter for EWMA chart.\ncl::Float64: Control limit for the EWMA chart.\nlookup_array_op: Array to lookup ordinal patterns. Can be created with functioncomputelookuparray_op()`.\np_reps::Vector{Int}: Unit range of repetitions.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1}: DGP.\nop_dgp_dist::UnivariateDistribution: Distribution of the DGP.\nchart_choice::Int: Chart choice (1: XXX, 2: XXX, 3: XXX, 4: XXX, 5: XXX, 6: XXX).\nd::Union{Int,Vector{Int}}=1: Delay vector. Default is 1.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.\n\n\nrl_op(0.1, 3.0, lookup_array_op, 1:10_000, IC(Normal(0, 1)), Normal(0, 1), 1; d=1, ced=false, ad=100)"
  },
  {
    "objectID": "reference/rl_sacf.html",
    "href": "reference/rl_sacf.html",
    "title": "rl_sacf",
    "section": "",
    "text": "rl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf(\n\nlam, cl, d1::Int, d2::Int, preps::UnitRange, spatialdgp::ICSP, dist_error::UnivariateDistribution )\nCompute the in-control run length using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination. The function returns the run length for a given control limit cl.\nThe input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\np_reps::UnitRange: The number of repetitions to compute the run length. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\nspatial_dgp::ICSP: The in-control spatial data generating process (DGP) to use for the SACF function.\ndist_error::UnivariateDistribution: The distribution to use for the error term in the spatial process. This can be any univariate distribution from the Distributions.jl package.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf(\n\nlam, cl, d1::Int, d2::Int, preps::UnitRange, spatialdgp::SpatialDGP, disterror::UnivariateDistribution, distao::Union{UnivariateDistribution,Nothing} )\nCompute the out-of-control run length using the spatial autocorrelation function (SACF). The function returns the run length for a given control limit cl and a given number of repetitions reps.\nThe input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\np_reps::UnitRange: The number of repetitions to compute the run length. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\nspatial_dgp::SpatialDGP: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11."
  },
  {
    "objectID": "reference/QAR1.html",
    "href": "reference/QAR1.html",
    "title": "QAR1",
    "section": "",
    "text": "QAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nQAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a QAR(1) (quadratic AR) process:\n\\(\\qquad X_t=\\alpha \\cdot X_{t-1}^2+\\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nqar1 = QAR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "QAR1"
    ]
  },
  {
    "objectID": "reference/crit_val_sacf.html",
    "href": "reference/crit_val_sacf.html",
    "title": "crit_val_sacf",
    "section": "",
    "text": "crit_val_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncritvalsacf(M, N, alpha)\nComputes the critical value for the SACF of lag 1. The input parameters are:\n\nM::Int64: The number of rows in the data matrix.\nN::Int64: The number of columns in the data matrix.\nalpha::Float64: The significance level.\n\n\nExamples\n#| eval: false\n# compute critical value\ncrit_val_sacf(11, 11, 0.05)"
  },
  {
    "objectID": "reference/compute_p_array.html",
    "href": "reference/compute_p_array.html",
    "title": "compute_p_array",
    "section": "",
    "text": "compute_p_array\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncompute_p_array(data::Array{T,3})\n\nCompute the matrix of p-hat values for a given 3D array of data when the delays are integers. These values are used for bootstrapping."
  },
  {
    "objectID": "reference/chart_stat_sop.html",
    "href": "reference/chart_stat_sop.html",
    "title": "chart_stat_sop",
    "section": "",
    "text": "chart_stat_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nchart_stat_sop(p_ewma, chart_choice)\n\nCompute the the test statistic for spatial ordinal patterns. The first input is a vector with three values, based on SOP counts. The second input is the chart."
  },
  {
    "objectID": "reference/ICSTS.html",
    "href": "reference/ICSTS.html",
    "title": "ICSTS",
    "section": "",
    "text": "ICSTS\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nICSP(M_rows, N_cols, dist)\n\nA struct to define an independent and identically distributed (IID) process for in-control\n\nM_rows::Int: The number of rows for the image.\nN_cols::Int: The number of columns for image.\ndist::UnivariateDistribution: A distribution from the Distributions.jl package."
  },
  {
    "objectID": "reference/arl_op.html",
    "href": "reference/arl_op.html",
    "title": "arl_op",
    "section": "",
    "text": "arl_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_op(lam, cl, op_dgp, reps=10_000; chart_choice, d=1, ced=false, ad=100)\n\nFunction to compute the average run length (ARL) for ordinal patterns using the EWMA statistic. The function implements the test statistics by Weiss and Testik (2023), who use a pattern length of 3.\n\nlam::Float64 Smoothing parameter for the EWMA statistic.\ncl::Float64 Control limit for the EWMA statistic.\nop_dgp::Union{IC, AR1, MA1, MA2, TEAR1, AAR1, QAR1} DGP.\nreps::Int64 Number of replications.\nchart_choice::Int\n\n\\(\\widehat{H}^{(d)}=-\\sum_{k=1}^{m!} \\hat{p}_k{ }^{(d)} \\ln \\hat{p}_k{ }^{(d)}\\)\n\\(\\widehat{H}_{\\mathrm{ex}}^{(d)}=-\\sum_{k=1}^{m!}\\left(1-\\hat{p}_k{ }^{(d)}\\right) \\ln \\left(1-\\hat{p}_k{ }^{(d)}\\right)\\)\n\\(\\widehat{\\Delta}^{(d)}=\\sum_{k=1}^{m!}\\left(\\hat{p}_k^{(d)}-1 / m!\\right)^2\\)\n\\(\\hat{\\beta}^{(d)}=\\hat{p}_6^{(d)}-\\hat{p}_1^{(d)}\\)\n\\(\\hat{\\tau}^{(d)}=\\hat{p}_6^{(d)}+\\hat{p}_1^{(d)}-\\frac{1}{3}\\)\n\\(\\hat{\\delta}^{(d)}=\\hat{p}_4^{(d)}+\\hat{p}_5^{(d)}-\\hat{p}_3^{(d)}-\\hat{p}_2^{(d)}\\)\n\nThe patterns are categorized as follows:\n\\(\\qquad p_1 = (3,2,1);  \\quad p_2=(3,1,2);  \\quad p_3 = (2,3,1);\\)\n\\(\\qquad p_4 = (1,3,2);  \\quad p_5 = (2,1,3);  \\quad p_ 6 = (1,2,3)\\)\nd::Union{Int,Vector{Int}}=1: Delay vector. Default is 1. A vector would denote the indices of the observations to use. For example, d = [1, 3, 4] would denote the first, third, and fourth observations.\nced::Bool=false: Use conditional expected delay? Default is false.\nad::Int=100: Number of iterations for ced.\n\n\n# Compute initial values via function cl_op()\n if j == 1 || j == 2\n      cl_init = quantile(stat_op(data, lam[i], j)[1], 0.01)                \n  else\n      cl_init = quantile(stat_op(data, lam[i], j)[1], 0.99)\nend \n\n# Run function\narl_op(0.1, cl_init, IC(Normal(0, 1)), 10_000; chart_choice=1, d=1, ced=false, ad=100)",
    "crumbs": [
      "API",
      "Functions for ordinal patterns",
      "arl_op"
    ]
  },
  {
    "objectID": "reference/SINAR11.html",
    "href": "reference/SINAR11.html",
    "title": "SINAR11",
    "section": "",
    "text": "SINAR11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSINAR11(dgp_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a first-order integer spatial autoregressive (SINAR(1, 1)) model:\n\\(\\qquad X_{t_1, t_2}=\\alpha_1 \\circ X_{t_1-1, t_2}+\\alpha_2 \\circ X_{t_1, t_2-1}+\\alpha_3 \\circ X_{t_1-1, t_2-1}+\\varepsilon_{t_1, t_2}.\\)\n\ndgp_params::Tuple(α₁::Float64, α₂::Float64, α₃::Float64) Note that α₁, α₂, and α₃ ∈ [0, 1) and α₁ + α₂ + α₃ &lt; 1 to guarantee stationarity.\nm::Int The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int A value to initialize the DGP to guarantee stationarity. These number of rows and columns will be discarded for the final spatial matrix.\ndist::Distribution A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing, Distribution} Nothing or a distribution for additive outliers. For additive outliers you can use any univariate distribution from the Distributions.jl package.\nprerun::Int A value to initialize the DGP to achieve stationarity. These number of rows and columns will be discarded after the initialization.\n\n\nsar11 = SINAR((0.5, 0.3, 0.2), 11, 11, 100)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SINAR11"
    ]
  },
  {
    "objectID": "reference/compute_lookup_array.html",
    "href": "reference/compute_lookup_array.html",
    "title": "compute_lookup_array",
    "section": "",
    "text": "compute_lookup_array\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nCompute a 4D array to lookup the index of the sops. The original SOPs are based on ranks. Here we use sortperm which computes the order of the elements in the vector."
  },
  {
    "objectID": "reference/SAR11.html",
    "href": "reference/SAR11.html",
    "title": "SAR11",
    "section": "",
    "text": "SAR11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSAR11(dgp_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a first-order spatial autoregressive (SAR(1, 1)) process:\n\\(\\qquad \\qquad Y_{t_1, t_2}=\\alpha_1 \\cdot Y_{t_1-1, t_2}+\\alpha_2 \\cdot Y_{t_1, t_2-1}+\\alpha_3 \\cdot Y_{t_1-1, t_2-1}+\\varepsilon_{t_1, t_2}\\)\n\nYₜ₁,ₜ₂ = α₁ ⋅ Yₜ₁₋₁,ₜ₂ + α₂ ⋅ Yₜ₁,ₜ₂₋₁ + α₃ ⋅ Yₜ₁₋₁,ₜ₂₋₁ + εₜ₁,ₜ₂\n\n\ndgp_params::Tuple(α₁::Float64, α₂::Float64, α₃::Float64) The requirements to guarantee stationarity for the process are |α₁| &lt; 1, |α₂| &lt; 1, |α₁ + α₂| &lt; 1 - α₃, and |α₁ - α₂| &lt; 1 + α₃.\nm::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nn::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\nprerun::Int: A value to initialize the DGP to achieve stationarity. These number of rows and columns will be discarded after the initialization.\ndist::Distribution: A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing, Distribution}: Nothing or a distribution for additive outliers. For additive outliers you can use any univariate distribution from the Distributions.jl package.\nprerun::Int: A value to initialize the DGP to guarantee stationarity. These number of rows and columns will be discarded for the final spatial matrix.\n\n\nsar11 = SAR11((0.5, 0.3, 0.2), 11, 11, Normal(0, 1), nothing, 100)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SAR11"
    ]
  },
  {
    "objectID": "reference/crit_val_sop.html",
    "href": "reference/crit_val_sop.html",
    "title": "crit_val_sop",
    "section": "",
    "text": "crit_val_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncritvalsop(m, n, alpha, chart_choice, approximate::Bool)\nComputes the critical value for the SOP test. Also allows the approximation of the critical value. The input parameters are:\n\nm::Int64: The number of rows in the sop-matrix. Note that the data matrix has dimensions M = m + d₁, where d₁ denotes the row delay.\nn::Int64: The number of columns in the sop-matrix. Note that the data matrix has dimensions N = n + d₂, where d₂ denotes the column delay.\nalpha::Float64: The significance level.\nchart_choice::Int64: The choice of chart.\napproximate::Bool: If true, the approximate critical value is computed. If false, the exact critical value is computed.\n\n\nExamples\n#| eval: false\n# compute approximate critical value for chart 1 \ncrit_val_sop(10, 10, 0.05, 1, true)"
  },
  {
    "objectID": "reference/arl_sacf.html",
    "href": "reference/arl_sacf.html",
    "title": "arl_sacf",
    "section": "",
    "text": "arl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\narlsacf(lam, cl, spatialdgp::ICSP, d1::Int, d2::Int, reps=10_000)\nCompute the in-control average run length (ARL), using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination. The function returns the ARL for a given control limit cl and a given number of repetitions reps.\nThe input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nspatial_dgp: The in-control spatial data generating process (DGP) to use for the SACF function.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\nreps: The number of repetitions to compute the ARL.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf(lam, cl, sp_dgp::SpatialDGP, d1::Int, d2::Int, reps=10_000)\n\nCompute the in-control average run length (ARL) using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination and an out-of-control process.\nThe input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nsp_dgp: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\nreps: The number of repetitions to compute the ARL.",
    "crumbs": [
      "API",
      "Functions for spatial ordinal patterns",
      "arl_sacf"
    ]
  },
  {
    "objectID": "reference/arl_sop_bp.html",
    "href": "reference/arl_sop_bp.html",
    "title": "arl_sop_bp",
    "section": "",
    "text": "arl_sop_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(\n\nlam, cl, spatialdgp::ICSP, d1vec::Vector{Int}, d2vec::Vector{Int}, reps=10000; chart_choice=3 )\nComputes the average run length (ARL) for a given in-control spatial DGP, using EWMA-BP-SOP statistics.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nspatial_dgp::ICSP: A struct for the in-control spatial DGP.\nd1_vec::Vector{Int}: A vector with integer values for the first delay (d₁).\nd2_vec::Vector{Int}: A vector with integer values for the second delay (d₂).\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4."
  },
  {
    "objectID": "replications/replication_ukraine.html",
    "href": "replications/replication_ukraine.html",
    "title": "",
    "section": "",
    "text": "using DataFrames\nusing DataFramesMeta\nusing OrdinalPatterns\nusing Dates\nusing CSV\nusing CategoricalArrays\nusing Plots"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "OrdinalPatterns.jl",
    "section": "",
    "text": "OrdinalPatterns.jl is a Julia package that provides functions to conduct (sequential) tests for time series data, using ordinal patterns. The package builds on the seminal work of Bandt and Pompe (2002). The package is highly optimized and fast. The package is designed to be easy to use and provides a simple interface to compute ordinal patterns from time series data.\n\n\nThe package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "OrdinalPatterns.jl",
    "section": "",
    "text": "The package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "reference.html",
    "href": "reference.html",
    "title": "Reference",
    "section": "",
    "text": "Reference\nWrite your references here."
  },
  {
    "objectID": "page_files/api_reference.html",
    "href": "page_files/api_reference.html",
    "title": "API",
    "section": "",
    "text": "API",
    "crumbs": [
      "API"
    ]
  },
  {
    "objectID": "page_files/op_changepoint.html",
    "href": "page_files/op_changepoint.html",
    "title": "Changepoint test",
    "section": "",
    "text": "Changepoint test\nOrdinalPatterns.jl allows to compute the chanegpoint statistic based on @schnurr2017.\n\nusing RCall\nusing OrdinalPatterns\nusing BenchmarkTools\n\ntsx = rand(100)\ntsy = rand(100)\n\n# R\n@rput tsx tsy \nR\"\"\"\nlibrary(ordinalpattern)\nresult_dep = patterndependence(tsx, tsy)\nresult_dep$patterncoef |&gt; print()\n\nmicrobenchmark::microbenchmark(\n  timing = patterndependence(tsx, tsy, tiesmethod=\"first\"), times = 100\n  )\n\"\"\"\n\n[1] -0.0874911\n\n\nRObject{VecSxp}\nUnit: microseconds\n   expr     min       lq     mean   median       uq     max neval\n timing 199.104 205.0205 232.4345 208.9325 220.7495 1006.12   100\n\n\n\nchangepoint_op(tsx, tsy, op_length=3)\n\n(0.6240403802109148, 73, 0.8309423384484209, (-1.3580986393225503, 1.3580986393225503))",
    "crumbs": [
      "OPs",
      "Changepoint test"
    ]
  },
  {
    "objectID": "page_files/op_breakpoint.html",
    "href": "page_files/op_breakpoint.html",
    "title": "Breakpoint detection",
    "section": "",
    "text": "Breakpoint detection"
  },
  {
    "objectID": "page_files/op_tutorial.html",
    "href": "page_files/op_tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "Tutorial",
    "crumbs": [
      "OPs",
      "Tutorial"
    ]
  },
  {
    "objectID": "page_files/op_dependence.html",
    "href": "page_files/op_dependence.html",
    "title": "Dependency test",
    "section": "",
    "text": "Dependency test\nOrdinalPatterns.jl allows to compute the dependency statistic based on @schnurr2017.\n\nusing RCall\nusing OrdinalPatterns\nusing BenchmarkTools\n\ntsx = rand(100)\ntsy = rand(100)\n\n# R\n@rput tsx tsy \nR\"\"\"\nlibrary(ordinalpattern)\nresult_dep = patterndependence(tsx, tsy)\nresult_dep$patterncoef |&gt; print()\n\nmicrobenchmark::microbenchmark(\n  timing = patterndependence(tsx, tsy, tiesmethod=\"first\"), times = 100\n  )\n\"\"\"\n\n[1] 0.05663208\n\n\nRObject{VecSxp}\nUnit: microseconds\n   expr     min      lq     mean   median       uq      max neval\n timing 201.519 206.829 233.7232 212.0885 221.1205 1049.512   100\n\n\n\ndependence_op(tsx, tsy; op_length=3, d=1)\n@btime dependence_op(tsx, tsy; op_length=3, d=1)\n\n  7.104 μs (44 allocations: 6.41 KiB)\n\n\n(0.05663207900987621, [6, 3, 2, 4, 1, 5, 6, 6, 3, 5  …  3, 1, 5, 3, 2, 3, 2, 4, 5, 4], [5, 4, 1, 1, 2, 3, 5, 6, 3, 2  …  1, 5, 4, 1, 2, 6, 6, 4, 1, 5])\n\n\n\nchangepoint_op(tsx, tsy, op_length=3)\n\n(1.3703353442726771, 59, 0.04677045774261557, (-1.3580986393225503, 1.3580986393225503))",
    "crumbs": [
      "OPs",
      "Dependency test"
    ]
  },
  {
    "objectID": "page_files/sop.html",
    "href": "page_files/sop.html",
    "title": "Spatial Ordinal Patterns",
    "section": "",
    "text": "Spatial Ordinal Patterns\nSpatial Ordinal Patterns (SOPs) are a way to …",
    "crumbs": [
      "SOPs",
      "Spatial Ordinal Patterns"
    ]
  },
  {
    "objectID": "tutorials/tutorial-01.html",
    "href": "tutorials/tutorial-01.html",
    "title": "First tutorial",
    "section": "",
    "text": "First tutorial\nThis is my first tutorial!"
  },
  {
    "objectID": "page_files/gop_tutorials.html",
    "href": "page_files/gop_tutorials.html",
    "title": "Generalized Ordinal Patterns",
    "section": "",
    "text": "Generalized Ordinal Patterns"
  },
  {
    "objectID": "page_files/sop_tutorial.html",
    "href": "page_files/sop_tutorial.html",
    "title": "Tutorial",
    "section": "",
    "text": "Tutorial\nThe tutorials using SOPs will be shown here…\n\n1+1\n\n2",
    "crumbs": [
      "SOPs",
      "Tutorial"
    ]
  },
  {
    "objectID": "page_files/op_replication.html",
    "href": "page_files/op_replication.html",
    "title": "Replication",
    "section": "",
    "text": "Replication",
    "crumbs": [
      "OPs",
      "Replication"
    ]
  },
  {
    "objectID": "page_files/installation.html",
    "href": "page_files/installation.html",
    "title": "Installation",
    "section": "",
    "text": "Installation\nThe package is currently not registered and has to be installed manually from GitHub."
  },
  {
    "objectID": "page_files/sop_replication.html",
    "href": "page_files/sop_replication.html",
    "title": "SOP Replication",
    "section": "",
    "text": "SOP Replication",
    "crumbs": [
      "SOPs",
      "SOP Replication"
    ]
  },
  {
    "objectID": "page_files/op.html",
    "href": "page_files/op.html",
    "title": "Ordinal Patterns",
    "section": "",
    "text": "Ordinal Patterns\nOrdinal Patterns (OPs) are a method to. They have been used in the context of …",
    "crumbs": [
      "OPs",
      "Ordinal Patterns"
    ]
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Tutorials\nDescribe your tutorials here."
  },
  {
    "objectID": "replications/replication_tm.html",
    "href": "replications/replication_tm.html",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "# Load packages\nusing OrdinalPatterns\nusing LinearAlgebra\nusing Cthulhu\nBLAS.set_num_threads(1); # Set BLAS threads to 1 when using multithreading\n\n# Parameters\nreps = 1_000;\nlam = 0.1\ncl = 0.03049\n\n# In-control limits SOPs\nic_sop = [\n    0.03049 0.05426 0.03174 0.05209;\n    0.02036 0.03626 0.02122 0.03476;\n    0.01223 0.0218 0.01276 0.02087;\n    0.00967 0.01724 0.01009 0.01650\n]\n\nic_sacf_cont = [0.05313, 0.03701, 0.02310, 0.01847]\nic_sacf_count = [0.05305, 0.03698, 0.02309, 0.01847]\n\n\n\n\n# Build struct\nsop_dgp = ICSP(\n    11,\n    11,\n    Normal(0, 1)\n)\n\n# Limits SOPs\nL0 = 370\ncl_init = 0.01\ncl_sop(sop_dgp, 0.1, L0, cl_init, 1, 1, 10_000; chart_choice=1, jmin=4, jmax=7, verbose=true)\n\n# Verify ARL\nlam = 0.1\ncl = 0.03049\narl_sop(sop_dgp, lam, cl, 1, 1, 10_000; chart_choice=1)\n\n\n\n\n\nMN_vec = [(11, 11), (16, 16), (26, 26), (41, 26)];\ndgp_vals = [\n    (0.1, 0.1, 0.1);\n    (0.2, 0.2, 0.2);\n    (0.2, 0.2, 0.5);\n    (0.4, 0.3, 0.1)\n]\nresults_mat = zeros(4 * 4, 5)\n\n\ni = 1\nfor alphas in dgp_vals\n    for (j, mn_tup) in enumerate(MN_vec)\n        M = mn_tup[1]\n        N = mn_tup[2]\n        for chart in 1:4\n            cl_sop = ic_sop[j, chart]\n            cl_sacf = ic_sacf_cont[j]\n            sop_dgp = SAR11(alphas, M, N, Normal(0, 1), nothing, 100)\n            res_sop = arl_sop(sop_dgp, lam, cl_sop, 1, 1, reps; chart_choice=chart)\n            res_sacf = arl_sacf(sop_dgp, lam, cl_sacf, 1, 1, reps)\n            results_mat[i, chart] = res_sop[1]\n            results_mat[i, 5] = res_sacf[1]\n        end\n        i = i + 1\n        println(i)\n    end\nend\nround.(results_mat, digits=2)\n\n\n\n\n\ni = 1\nfor alphas in dgp_vals\n    for (j, mn_tup) in enumerate(MN_vec)\n        M = mn_tup[1]\n        N = mn_tup[2]\n        for chart in 1:4\n            cl_sop = ic_sop[j, chart]\n            cl_sacf = ic_sacf_count[j]\n            sop_dgp = SINAR11(alphas, M, N, Poisson(5), nothing, 100)\n            res_sop = arl_sop(sop_dgp, lam, cl_sop, 1, 1, reps; chart_choice=chart)\n            res_sacf = arl_sacf(sop_dgp, lam, cl_sacf, 1, 1, reps)\n            results_mat[i, chart] = res_sop[1]\n            results_mat[i, 5] = res_sacf[1]\n        end\n        i = i + 1\n        println(i)\n    end\nend\nround.(results_mat, digits=2)\n\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 11, 11, Normal(0,1), nothing, 100)\n@descend rl_sacf(\n  spatial_dgp, 0.1, 0.05305, 1, 1, 1:10, \n  Poisson(5), nothing\n)\n\n\n\n\n\ndata_all = randn(50, 50, 1000)\ndata = data_all[:, :, 1]\nd1 = 1\nd2 = 1\nd1_vec = [1, 2]\nd2_vec = [1, 2]\n\nstat_sop(data, d1, d2)\nstat_sop(0.1, data_all, d1, d2; add_noise = true)\n@btime stat_sop(0.1, $data_all, $d1, $d2; add_noise = true)\n\nstat_sop(data, d1_vec, d2_vec; add_noise = true)\nstat_sop(0.1, data_all, d1_vec, d2_vec; add_noise = true)\n@btime stat_sop(0.1, $data_all, $d1_vec, $d2_vec; add_noise = true)\n\n\ndata = randn(41, 26, 370);\nspatial_dgp = ICSP(41, 26, Normal(0, 1))\nlam = 0.1\nL0 = 370\nd1_vec = [1, 2]\nd2_vec = [1, 2]\n\nlookup_array_sop = compute_lookup_array_sop()\ncl_init = stat_sop(lam, data, d1_vec, d2_vec; chart_choice=3, add_noise=false) |&gt; x -&gt; last(x)\n@btime rl_sop(lam, cl_init, lookup_array_sop, spatial_dgp, 1:5_00, Normal(0, 1), 3, d1_vec, d2_vec)\n\ncl_sop(lam, L0, spatial_dgp, cl_init, 2, 2, 1_000; chart_choice=3, jmin=4, jmax=6, verbose=true)\narl_sop(lam, 0.0269, spatial_dgp, d1_vec, d2_vec, 100; chart_choice=3)\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sop(lam, 0.0269, spatial_dgp, d1_vec, d2_vec, 1_000; chart_choice=3)\n\nBLAS.set_num_threads(1);\nspatial_sar1 = SAR1((0.1, 0.1, 0.1, 0.1), 11, 11, Normal(0, 1), nothing, 20)\narl_sop(0.1, 0.01037, spatial_sar1, 2, 2, 1_000; chart_choice=3)\narl_sop(0.1, 0.03174, spatial_sar1, 1, 1, 1_000; chart_choice=3)\n\nspatial_sar11 = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sop(0.1, 0.0214, spatial_sar11, d1_vec, d2_vec, 1_000; chart_choice=3)\n\n\nstat_sacf(rand(10, 10), 1, 1)\nx = rand(10, 10, 1000)\n@btime stat_sacf(0.1, $x, 2, 2)\n\n@btime stat_sacf(0.1, x, [1, 2, 3], [1, 2, 3]) \n\ncl_sacf(0.1, 370, ICSP(11, 11, Normal(0, 1)), 0.04 , 1, 1, 1000; jmin=4, jmax=6, verbose=true)\n\n\nx = rand(41, 26, 370);\n\n# Starting values\nmap(i -&gt; stat_sacf(0.1, rand(41, 26, 370), [1, 2], [1, 2]) |&gt; last, 1:100) |&gt; x -&gt; quantile(x, 0.01)\n\ncl_sacf(0.1, 370, ICSP(41, 26, Normal(0, 1)), 0.11, [1, 2], [1, 2], 1_000; jmin=4, jmax=7, verbose=true)\n@btime rl_sacf(0.1, 0.088, ICSP(40, 40, Normal(0, 1)), [1, 2], [1, 2], 1:100, Normal(0, 1))\n\nstat_sacf(0.1, rand(41, 26, 370), 2, 2) |&gt; x -&gt; quantile(x, 0.99)\ncl_sacf(0.1, 370, ICSP(41, 26, Normal(0, 1)), 0.013, 2, 2, 1_000; jmin=4, jmax=7, verbose=true)\n\nspatial_sar11 = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sacf(0.1, 0.1341, spatial_sar11, [1, 2],  [1, 2], 100)\narl_sacf(0.1, 0.013, spatial_sar11, 2,  2, 1000)\n\n arl_sacf(lam, cl, spatial_dgp::SpatialDGP, d1_vec::Vector{Int}, d2_vec::Vector{Int}, reps=10_000)\n\n\nSAR22(\n    (0.0, 0.0, 0.0, 0.4, 0.3, 0.0, 0.0, 0.1), \n    41, 26, \n    Normal(0, 1), \n    nothing, \n    100\n    )\n \n SQMA22(\n    (0.0, 0.0, 0.0, 0.8, 0.8, 0.0, 0.0, 0.8), \n    (0.0, 0.0, 0.0, 2,     2, 0.0, 0.0, 2),\n    41, 26, \n    Normal(0, 1), \n    nothing, \n    100\n    )\n\n\n\n\n\ndata = rand(250, 250, 94)\narl_sop(lam, cl, data, 1000; chart_choice=1, d1=3, d2=3)\nstat_sop(0.1, data; chart_choice=3, add_noise=false) |&gt; x -&gt; quantile(x, 0.99)\ncl_sop(0.1, L0, data, 0.0005, 1_000; chart_choice=3, verbose=true, d1=1, d2=1)\n\n\npmat = compute_p_mat(data)\np_ewma = vec(mean(pmat, dims=1))\nabs(chart_stat_sop(p_ewma, 3) - -0.14843259957606353)\nstat_sop(0.1, images; chart_choice=3, add_noise=false) |&gt; x -&gt; quantile(x, 0.01)\n\narl_sop(0.1, 0.003, pmat, 10; chart_choice=3)\n\narl_sop\ncl_sop(0.1, L0, data, 0.003, 1_000; chart_choice=3, verbose=true, d1=1, d2=1)\n\ncl_sop(0.1, L0, pmat, 0.003, 10_000; chart_choice=3, jmin=4, jmax=6, verbose=true, d1=1, d2=1)\n\n\n\n\n\nusing Makie\nusing CairoMakie\nusing RCall\nusing OrdinalPatterns\nR\"\"\"\nlibrary(textile)\nlibrary(spc4sts)\nimages = textile::icImgs\nmodel = readRDS(\"/home/adaemmerp/Downloads/model.rds\")\n\n# In-control\nresid_ic_mat = array(NA, c(235, 220, 94))\nfor (i in 1:94) {\n\n  dat &lt;- dataPrep(textile::icImgs[, , i], model$nb)\n  r0j &lt;- dat[, 1] - predict(model$fit, dat)\n  res &lt;- matrix(r0j, nrow(textile::icImgs[, , i]) - model$nb[1],\n               ncol(textile::icImgs[, , i]) - sum(model$nb[2:3]), byrow=TRUE)\n  resid_ic_mat[, , i] = res\n}\n\n# Out-of control\nresid_oc_mat = array(NA, c(235, 220, 6))\nfor (i in 1:6) {\n  \n  dat &lt;- dataPrep(textile::ocImgs[, , i], model$nb)\n  r0j &lt;- dat[, 1] - predict(model$fit, dat)\n  res &lt;- matrix(r0j, nrow(textile::ocImgs[, , i]) - model$nb[1],\n                ncol(textile::ocImgs[, , i]) - sum(model$nb[2:3]), byrow=TRUE)\n  resid_oc_mat[, , i] = res\n}\n\n\"\"\"\n@rget resid_ic_mat resid_oc_mat\n\nlam = 0.1\nreps_range = 1:100\nchart_choice = 3\nw = 3\n\n# Compute critical limits for BP-statistic\ncl = cl_sop_bp(\n  resid_ic_mat, lam, 20, 0.000013, w, 1_000;\n  chart_choice=3, jmin=4, jmax=6, verbose=true\n)\n\n# Compute in-control values    \np_array = compute_p_array_bp(resid_ic_mat, w; chart_choice=chart_choice) # Compute relative frequencies for p-vectors\np_array_mean = mean(p_array, dims=1)\n# Make column vectors to be compatible with p_ewma_all\np_array_mean = permutedims(p_array_mean, (2, 1, 3)) \n\n# Compute in-control values for test statitic\nstat_ic = zeros(size(p_array_mean, 3)) # third dimension is number of d1-d2 combinations\n\nfor i in axes(p_array_mean, 3)\n  @views stat_ic[i] = chart_stat_sop(p_array_mean[:, :, i], chart_choice)\nend\n\nstats_bp = stat_sop_bp(\n  resid_oc_mat,\n  lam,\n  w,  \n  chart_choice=3,\n  add_noise=false,\n  stat_ic=stat_ic,\n  type_freq_init=p_array_mean\n)\n\n# Use Makie to plots stats_bp. Draw in red the critical limits\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, stats_bp, color=:blue)\nhlines!(ax, [cl], color=:red)\nfig\n\n\n\n\n\nusing OrdinalPatterns\nusing RCall\nR\"\"\"\nlibrary(textile)\nlibrary(spc4sts)\nimages_ic = textile::icImgs\nimages_oc = textile::ocImgs\n\"\"\"\n\n@rget images_ic images_oc;\n\n# Compute sequence of pictures\nx = rand(100, 100, 370)\nstat_sop(0.1, x, [1, 2, 3], [1, 2, 3])\n\n\n# Compute critical limits for BP-statistic\ncl_sop(\n  0.1, 370, ICSP(100, 100, Normal(0, 1)), 0.005,  [1, 2, 3], [1, 2, 3], 100;\n  chart_choice=3, jmin=4, jmax=6, verbose=true\n)\n\n# Get values for BP statistic\nstat_sop(images_ic[:, :, 2], [1, 2, 3], [1, 2, 3])\nstat_sop(1, images_ic[:, :, 2:3], [1, 2, 3], [1, 2, 3])\n\np_array = compute_p_array(images_ic, [1, 2, 3], [1, 2, 3])\n\ncl_sop(\n 1, 80, p_array, 0.1, 100;\n  chart_choice=3, jmin=1, jmax=6, verbose=false\n)\n\nstat_sop(0.1, images_oc, [1, 2, 3], [1, 2, 3])\n\n\n\n\n\ndata = rand(50, 50)\n\nstat_sop(data; chart_choice=1)\ndata = rand(100, 100, 200)\nstat_sop(0.1, data; chart_choice=1, add_noise=false)\n\n\n@btime rand(Normal(0, 1));\n@btime rand(TDist(5));\n\n@btime rand(Binomial(10, 0.5));\n@btime rand(Poisson(5));",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#table-1",
    "href": "replications/replication_tm.html#table-1",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "# Build struct\nsop_dgp = ICSP(\n    11,\n    11,\n    Normal(0, 1)\n)\n\n# Limits SOPs\nL0 = 370\ncl_init = 0.01\ncl_sop(sop_dgp, 0.1, L0, cl_init, 1, 1, 10_000; chart_choice=1, jmin=4, jmax=7, verbose=true)\n\n# Verify ARL\nlam = 0.1\ncl = 0.03049\narl_sop(sop_dgp, lam, cl, 1, 1, 10_000; chart_choice=1)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#table-a.1",
    "href": "replications/replication_tm.html#table-a.1",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "MN_vec = [(11, 11), (16, 16), (26, 26), (41, 26)];\ndgp_vals = [\n    (0.1, 0.1, 0.1);\n    (0.2, 0.2, 0.2);\n    (0.2, 0.2, 0.5);\n    (0.4, 0.3, 0.1)\n]\nresults_mat = zeros(4 * 4, 5)\n\n\ni = 1\nfor alphas in dgp_vals\n    for (j, mn_tup) in enumerate(MN_vec)\n        M = mn_tup[1]\n        N = mn_tup[2]\n        for chart in 1:4\n            cl_sop = ic_sop[j, chart]\n            cl_sacf = ic_sacf_cont[j]\n            sop_dgp = SAR11(alphas, M, N, Normal(0, 1), nothing, 100)\n            res_sop = arl_sop(sop_dgp, lam, cl_sop, 1, 1, reps; chart_choice=chart)\n            res_sacf = arl_sacf(sop_dgp, lam, cl_sacf, 1, 1, reps)\n            results_mat[i, chart] = res_sop[1]\n            results_mat[i, 5] = res_sacf[1]\n        end\n        i = i + 1\n        println(i)\n    end\nend\nround.(results_mat, digits=2)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#table-a.2",
    "href": "replications/replication_tm.html#table-a.2",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "i = 1\nfor alphas in dgp_vals\n    for (j, mn_tup) in enumerate(MN_vec)\n        M = mn_tup[1]\n        N = mn_tup[2]\n        for chart in 1:4\n            cl_sop = ic_sop[j, chart]\n            cl_sacf = ic_sacf_count[j]\n            sop_dgp = SINAR11(alphas, M, N, Poisson(5), nothing, 100)\n            res_sop = arl_sop(sop_dgp, lam, cl_sop, 1, 1, reps; chart_choice=chart)\n            res_sacf = arl_sacf(sop_dgp, lam, cl_sacf, 1, 1, reps)\n            results_mat[i, chart] = res_sop[1]\n            results_mat[i, 5] = res_sacf[1]\n        end\n        i = i + 1\n        println(i)\n    end\nend\nround.(results_mat, digits=2)\n\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 11, 11, Normal(0,1), nothing, 100)\n@descend rl_sacf(\n  spatial_dgp, 0.1, 0.05305, 1, 1, 1:10, \n  Poisson(5), nothing\n)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#try-bp-statistic",
    "href": "replications/replication_tm.html#try-bp-statistic",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "data_all = randn(50, 50, 1000)\ndata = data_all[:, :, 1]\nd1 = 1\nd2 = 1\nd1_vec = [1, 2]\nd2_vec = [1, 2]\n\nstat_sop(data, d1, d2)\nstat_sop(0.1, data_all, d1, d2; add_noise = true)\n@btime stat_sop(0.1, $data_all, $d1, $d2; add_noise = true)\n\nstat_sop(data, d1_vec, d2_vec; add_noise = true)\nstat_sop(0.1, data_all, d1_vec, d2_vec; add_noise = true)\n@btime stat_sop(0.1, $data_all, $d1_vec, $d2_vec; add_noise = true)\n\n\ndata = randn(41, 26, 370);\nspatial_dgp = ICSP(41, 26, Normal(0, 1))\nlam = 0.1\nL0 = 370\nd1_vec = [1, 2]\nd2_vec = [1, 2]\n\nlookup_array_sop = compute_lookup_array_sop()\ncl_init = stat_sop(lam, data, d1_vec, d2_vec; chart_choice=3, add_noise=false) |&gt; x -&gt; last(x)\n@btime rl_sop(lam, cl_init, lookup_array_sop, spatial_dgp, 1:5_00, Normal(0, 1), 3, d1_vec, d2_vec)\n\ncl_sop(lam, L0, spatial_dgp, cl_init, 2, 2, 1_000; chart_choice=3, jmin=4, jmax=6, verbose=true)\narl_sop(lam, 0.0269, spatial_dgp, d1_vec, d2_vec, 100; chart_choice=3)\nspatial_dgp = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sop(lam, 0.0269, spatial_dgp, d1_vec, d2_vec, 1_000; chart_choice=3)\n\nBLAS.set_num_threads(1);\nspatial_sar1 = SAR1((0.1, 0.1, 0.1, 0.1), 11, 11, Normal(0, 1), nothing, 20)\narl_sop(0.1, 0.01037, spatial_sar1, 2, 2, 1_000; chart_choice=3)\narl_sop(0.1, 0.03174, spatial_sar1, 1, 1, 1_000; chart_choice=3)\n\nspatial_sar11 = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sop(0.1, 0.0214, spatial_sar11, d1_vec, d2_vec, 1_000; chart_choice=3)\n\n\nstat_sacf(rand(10, 10), 1, 1)\nx = rand(10, 10, 1000)\n@btime stat_sacf(0.1, $x, 2, 2)\n\n@btime stat_sacf(0.1, x, [1, 2, 3], [1, 2, 3]) \n\ncl_sacf(0.1, 370, ICSP(11, 11, Normal(0, 1)), 0.04 , 1, 1, 1000; jmin=4, jmax=6, verbose=true)\n\n\nx = rand(41, 26, 370);\n\n# Starting values\nmap(i -&gt; stat_sacf(0.1, rand(41, 26, 370), [1, 2], [1, 2]) |&gt; last, 1:100) |&gt; x -&gt; quantile(x, 0.01)\n\ncl_sacf(0.1, 370, ICSP(41, 26, Normal(0, 1)), 0.11, [1, 2], [1, 2], 1_000; jmin=4, jmax=7, verbose=true)\n@btime rl_sacf(0.1, 0.088, ICSP(40, 40, Normal(0, 1)), [1, 2], [1, 2], 1:100, Normal(0, 1))\n\nstat_sacf(0.1, rand(41, 26, 370), 2, 2) |&gt; x -&gt; quantile(x, 0.99)\ncl_sacf(0.1, 370, ICSP(41, 26, Normal(0, 1)), 0.013, 2, 2, 1_000; jmin=4, jmax=7, verbose=true)\n\nspatial_sar11 = SAR11((0.1, 0.1, 0.1), 41, 26, Normal(0, 1), nothing, 100)\narl_sacf(0.1, 0.1341, spatial_sar11, [1, 2],  [1, 2], 100)\narl_sacf(0.1, 0.013, spatial_sar11, 2,  2, 1000)\n\n arl_sacf(lam, cl, spatial_dgp::SpatialDGP, d1_vec::Vector{Int}, d2_vec::Vector{Int}, reps=10_000)\n\n\nSAR22(\n    (0.0, 0.0, 0.0, 0.4, 0.3, 0.0, 0.0, 0.1), \n    41, 26, \n    Normal(0, 1), \n    nothing, \n    100\n    )\n \n SQMA22(\n    (0.0, 0.0, 0.0, 0.8, 0.8, 0.0, 0.0, 0.8), \n    (0.0, 0.0, 0.0, 2,     2, 0.0, 0.0, 2),\n    41, 26, \n    Normal(0, 1), \n    nothing, \n    100\n    )",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#botstraping",
    "href": "replications/replication_tm.html#botstraping",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "data = rand(250, 250, 94)\narl_sop(lam, cl, data, 1000; chart_choice=1, d1=3, d2=3)\nstat_sop(0.1, data; chart_choice=3, add_noise=false) |&gt; x -&gt; quantile(x, 0.99)\ncl_sop(0.1, L0, data, 0.0005, 1_000; chart_choice=3, verbose=true, d1=1, d2=1)\n\n\npmat = compute_p_mat(data)\np_ewma = vec(mean(pmat, dims=1))\nabs(chart_stat_sop(p_ewma, 3) - -0.14843259957606353)\nstat_sop(0.1, images; chart_choice=3, add_noise=false) |&gt; x -&gt; quantile(x, 0.01)\n\narl_sop(0.1, 0.003, pmat, 10; chart_choice=3)\n\narl_sop\ncl_sop(0.1, L0, data, 0.003, 1_000; chart_choice=3, verbose=true, d1=1, d2=1)\n\ncl_sop(0.1, L0, pmat, 0.003, 10_000; chart_choice=3, jmin=4, jmax=6, verbose=true, d1=1, d2=1)",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#image-example-with-apley",
    "href": "replications/replication_tm.html#image-example-with-apley",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "using Makie\nusing CairoMakie\nusing RCall\nusing OrdinalPatterns\nR\"\"\"\nlibrary(textile)\nlibrary(spc4sts)\nimages = textile::icImgs\nmodel = readRDS(\"/home/adaemmerp/Downloads/model.rds\")\n\n# In-control\nresid_ic_mat = array(NA, c(235, 220, 94))\nfor (i in 1:94) {\n\n  dat &lt;- dataPrep(textile::icImgs[, , i], model$nb)\n  r0j &lt;- dat[, 1] - predict(model$fit, dat)\n  res &lt;- matrix(r0j, nrow(textile::icImgs[, , i]) - model$nb[1],\n               ncol(textile::icImgs[, , i]) - sum(model$nb[2:3]), byrow=TRUE)\n  resid_ic_mat[, , i] = res\n}\n\n# Out-of control\nresid_oc_mat = array(NA, c(235, 220, 6))\nfor (i in 1:6) {\n  \n  dat &lt;- dataPrep(textile::ocImgs[, , i], model$nb)\n  r0j &lt;- dat[, 1] - predict(model$fit, dat)\n  res &lt;- matrix(r0j, nrow(textile::ocImgs[, , i]) - model$nb[1],\n                ncol(textile::ocImgs[, , i]) - sum(model$nb[2:3]), byrow=TRUE)\n  resid_oc_mat[, , i] = res\n}\n\n\"\"\"\n@rget resid_ic_mat resid_oc_mat\n\nlam = 0.1\nreps_range = 1:100\nchart_choice = 3\nw = 3\n\n# Compute critical limits for BP-statistic\ncl = cl_sop_bp(\n  resid_ic_mat, lam, 20, 0.000013, w, 1_000;\n  chart_choice=3, jmin=4, jmax=6, verbose=true\n)\n\n# Compute in-control values    \np_array = compute_p_array_bp(resid_ic_mat, w; chart_choice=chart_choice) # Compute relative frequencies for p-vectors\np_array_mean = mean(p_array, dims=1)\n# Make column vectors to be compatible with p_ewma_all\np_array_mean = permutedims(p_array_mean, (2, 1, 3)) \n\n# Compute in-control values for test statitic\nstat_ic = zeros(size(p_array_mean, 3)) # third dimension is number of d1-d2 combinations\n\nfor i in axes(p_array_mean, 3)\n  @views stat_ic[i] = chart_stat_sop(p_array_mean[:, :, i], chart_choice)\nend\n\nstats_bp = stat_sop_bp(\n  resid_oc_mat,\n  lam,\n  w,  \n  chart_choice=3,\n  add_noise=false,\n  stat_ic=stat_ic,\n  type_freq_init=p_array_mean\n)\n\n# Use Makie to plots stats_bp. Draw in red the critical limits\nfig = Figure()\nax = Axis(fig[1, 1])\nlines!(ax, stats_bp, color=:blue)\nhlines!(ax, [cl], color=:red)\nfig",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#images",
    "href": "replications/replication_tm.html#images",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "using OrdinalPatterns\nusing RCall\nR\"\"\"\nlibrary(textile)\nlibrary(spc4sts)\nimages_ic = textile::icImgs\nimages_oc = textile::ocImgs\n\"\"\"\n\n@rget images_ic images_oc;\n\n# Compute sequence of pictures\nx = rand(100, 100, 370)\nstat_sop(0.1, x, [1, 2, 3], [1, 2, 3])\n\n\n# Compute critical limits for BP-statistic\ncl_sop(\n  0.1, 370, ICSP(100, 100, Normal(0, 1)), 0.005,  [1, 2, 3], [1, 2, 3], 100;\n  chart_choice=3, jmin=4, jmax=6, verbose=true\n)\n\n# Get values for BP statistic\nstat_sop(images_ic[:, :, 2], [1, 2, 3], [1, 2, 3])\nstat_sop(1, images_ic[:, :, 2:3], [1, 2, 3], [1, 2, 3])\n\np_array = compute_p_array(images_ic, [1, 2, 3], [1, 2, 3])\n\ncl_sop(\n 1, 80, p_array, 0.1, 100;\n  chart_choice=3, jmin=1, jmax=6, verbose=false\n)\n\nstat_sop(0.1, images_oc, [1, 2, 3], [1, 2, 3])",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "replications/replication_tm.html#compute-test-statictis-based-on-series-of-pictures",
    "href": "replications/replication_tm.html#compute-test-statictis-based-on-series-of-pictures",
    "title": "Replication of Adaemmer et al. (2024)",
    "section": "",
    "text": "data = rand(50, 50)\n\nstat_sop(data; chart_choice=1)\ndata = rand(100, 100, 200)\nstat_sop(0.1, data; chart_choice=1, add_noise=false)\n\n\n@btime rand(Normal(0, 1));\n@btime rand(TDist(5));\n\n@btime rand(Binomial(10, 0.5));\n@btime rand(Poisson(5));",
    "crumbs": [
      "SOPs",
      "Replication of Adaemmer et al. (2024)"
    ]
  },
  {
    "objectID": "reference/BinomialCvec.html",
    "href": "reference/BinomialCvec.html",
    "title": "BinomialCvec",
    "section": "",
    "text": "BinomialCvec\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBinomialCvec{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a binomial distribution, which gets multiplied by a value from vector c_vec.\n`julia-repl dist = BinomialCvec(0.5, [-10; 10]) rand(dist)``"
  },
  {
    "objectID": "reference/IC.html",
    "href": "reference/IC.html",
    "title": "IC",
    "section": "",
    "text": "IC\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nIC(dist::UnivariateDistribution)\n\nA struct to define the in-control (IC) process. The struct contains one field, namely dist::UnivariateDistribution, which is the distribution of the in-control process.\n\nic = IC(Normal(0, 1))"
  },
  {
    "objectID": "reference/cl_sacf_bp.html",
    "href": "reference/cl_sacf_bp.html",
    "title": "cl_sacf_bp",
    "section": "",
    "text": "cl_sacf_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sacf_bp(\n  lam, L0, sp_dgp::ICSP, cl_init, w::Int, reps=10_000; \n  jmin=4, jmax=6, verbose::Bool=false\n)\n\nCompute the control limit for BP-EWMA control chart for multiple delay (d₁-d₂) combinations, using the spatial autocorrelation function (SACF) and an in-control spatial process (ICSP).\nThe function returns the control limit for a given average run.\n\nlam: The smoothing parameter for the EWMA control chart.\nL0: The average run length (ARL) to use for the control limit.\nsp_dgp: The in-control spatial process (ICSP) to use for the control limit.\ncl_init: The initial control limit to use for the control limit.\nd1_vec: The vector of first (row) delays for the spatial process.\nd2_vec: The vector of second (column) delays for the spatial process.\nreps: The number of repetitions to use for the control limit."
  },
  {
    "objectID": "reference/compute_lookup_array_sop.html",
    "href": "reference/compute_lookup_array_sop.html",
    "title": "compute_lookup_array_sop",
    "section": "",
    "text": "compute_lookup_array_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nCompute a 4D array to lookup the index of the sops. The original SOPs are based on ranks. Here we use sortperm which computes the order of the elements in the vector."
  },
  {
    "objectID": "reference/ZIP.html",
    "href": "reference/ZIP.html",
    "title": "ZIP",
    "section": "",
    "text": "ZIP\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nZIP &lt;: DiscreteUnivariateDistribution\n\nA struct to define a zero-inflated Poisson distribution.\n#| eval: false\ndist = ZIP(5.0, 0.2)\nrand(dist)"
  },
  {
    "objectID": "reference/compute_p_array_bp.html",
    "href": "reference/compute_p_array_bp.html",
    "title": "compute_p_array_bp",
    "section": "",
    "text": "compute_p_array_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\ncomputeparray(data::Array{Float64,3})\nCompute the matrix of p-hat values for a given 3D array of data when the delays are vectors of integers. These values are used for bootstrapping to compute critcial limits for the BP-statistics."
  },
  {
    "objectID": "reference/AR1.html",
    "href": "reference/AR1.html",
    "title": "AR1",
    "section": "",
    "text": "AR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define an AR(1) process:\n\\(\\qquad X_t = α  \\cdot X_{t-1} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nar1 = AR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "AR1"
    ]
  },
  {
    "objectID": "reference/sop_frequencies.html",
    "href": "reference/sop_frequencies.html",
    "title": "sop_frequencies",
    "section": "",
    "text": "sop_frequencies\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsop_frequencies(m::Int, n::Int, lookup_array_sop, n_sops, data, sop)\n\nCompute the frequencies of the spatial ordinal patterns. n_sops has to equal 24, as there are 4! = 24 possible patterns when using a 2x2 grid."
  },
  {
    "objectID": "reference/AAR1.html",
    "href": "reference/AAR1.html",
    "title": "AAR1",
    "section": "",
    "text": "AAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nAAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a AAR(1) (absolute AR) process:\n\\(\\qquad X_t=\\alpha \\cdot\\left|X_{t-1}\\right|+\\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\naar1 = AAR1(0.5, Normal(0, 1))"
  },
  {
    "objectID": "reference/stat_sop.html",
    "href": "reference/stat_sop.html",
    "title": "stat_sop",
    "section": "",
    "text": "stat_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nfunction statsop( data::Union{SubArray,Array{T,2}}, d1::Int, d2::Int; chartchoice=3, add_noise::Bool=false ) where {T&lt;:Real}\nComputes the test statistic for a single picture and chosen test statistic. chart_coice is an integer value for the chart choice. The options are 1-4.\n\nExamples\n#| eval: false\ndata = rand(20, 20);\n\nstat_sop(data, 2)\n\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nstatsop(data::Array{Float64, 3}, addnoise::Bool, lam::Float64, chart_choice::Int)\nComputes the test statistic for a 3D array of data, a given lambda value, and a given chart choice. The input parameters are:\n\ndata::Array{Float64,3}: A 3D array of data.\nadd_noise::Bool: A boolean value whether to add noise to the data. This is necessary when the matrices consist of count data.\nlam::Float64: A scalar value for lambda.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\n\n\nExamples\n#| eval: false\ndata = rand(20, 20, 10);\nlam = 0.1;\nchart_choice = 2;\n\nstat_sop(data, false, lam, chart_choice)"
  },
  {
    "objectID": "reference/cl_sacf.html",
    "href": "reference/cl_sacf.html",
    "title": "cl_sacf",
    "section": "",
    "text": "cl_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncl_sacf(\n  sp_dgp::ICSTS, lam, L0, cl_init, d1::Int, d2::Int, reps=10_000;\n\njmin=4, jmax=6, verbose=false )\nCompute the control limit for the exponentially weighted moving average (EWMA) control chart for one delay (d₁-d₂) combination, using the spatial autocorrelation function (SACF) and an in-control spatial process (ICSP).\nThe function returns the control limit for a given average run.\n\nsp_dgp: The in-control spatial process (ICSP) to use for the control limit.\nlam: The smoothing parameter for the EWMA control chart.\nL0: The average run length (ARL) to use for the control limit.\ncl_init: The initial control limit to use for the control limit.\nd1: The first (row) delay for the spatial process.\nd2: The second (column) delay for the spatial process.\nreps: The number of repetitions to use for the control limit.\njmin: The minimum number of values to change after the decimal point in the control limit.\njmax: The maximum number of values to change after the decimal point in the control limit.\nverbose: A boolean to indicate whether to print the control limit and ARL for each iteration.\n\n\n#--- Example\n# Parameters\nlam = 0.1\nL0 = 370\nsp_dgp = ICSP(20, 20, Normal(0, 1))\ncl_init = 0.5\nd1 = 1\nd2 = 1\nreps = 10_000\njmin = 4\njmax = 6"
  },
  {
    "objectID": "reference/count_uv_op.html",
    "href": "reference/count_uv_op.html",
    "title": "count_uv_op",
    "section": "",
    "text": "count_uv_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncount_uv_op(ts; op_length::Int=3, d=1)\n\nCount the number of ordinal patterns in bins for a single time series ts.\n\nts::Vector{Float64}: Time series for which the ordinal patterns are counted.\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\nts = rand(100)\ncount_uv_op(ts; op_length=3, d=1)"
  },
  {
    "objectID": "reference/SQMA22.html",
    "href": "reference/SQMA22.html",
    "title": "SQMA22",
    "section": "",
    "text": "SQMA22\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSQMA22(dgp_params, eps_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a Spatial quadratic moving-average (SQMA(1, 1)):\n`` Y{t1, t*2} = ^a\n\n ^b\n ^c\n ^d\n ^e\n ^f\n ^g\n ^h\n. ``\n\nYₜ₁,ₜ₂ = β₁ ⋅ εₜ₁₋₁,ₜ₂ᵃ + β₂ ⋅ εₜ₁,ₜ₂₋₁ᵇ + β₃ ⋅ εₜ₁₋₁,ₜ₂₋₁ᶜ + β₄ ⋅ εₜ₁₋₂,ₜ₂ᵈ + β₅ ⋅ εₜ₁,ₜ₂₋₂ᵉ + β₆ ⋅ εₜ₁₋₂,ₜ₂₋₁ᶠ + β₇ ⋅ εₜ₁₋₁,ₜ₂₋₂ᵍ + β₈ ⋅ εₜ₁₋₂,ₜ₂₋₂ʰ + εₜ₁,ₜ₂"
  },
  {
    "objectID": "reference/arl_sop_bootstrap.html",
    "href": "reference/arl_sop_bootstrap.html",
    "title": "arl_sop_bootstrap",
    "section": "",
    "text": "arl_sop_bootstrap\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop_bootstrap(p_mat::Array{Float64,2}, lam, cl, reps=10_000; chart_choice=chart_choice)\n\nCompute the average run length (ARL) using a bootstrap approach for a particular delay (d₁-d₂) combination.\nThe input parameters are:\n\np_mat::Array{Float64,2}: A matrix with the values of the relative type frequencies.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4. The default value is 3."
  },
  {
    "objectID": "reference/rl_sop.html",
    "href": "reference/rl_sop.html",
    "title": "rl_sop",
    "section": "",
    "text": "rl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(lam, cl, lookup_array_sop, reps_range, dist, chart_choice, m, n, d1::Int, d2::Int)\n\nCompute the run length for a given in-control spatial DGP.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\ndist::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nm::Int: An integer value for the number of rows for the final “SOP” matrix.\nn::Int: An integer value for the number of columns for the final “SOP” matrix.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂).\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(lam, cl, reps_range, chart_choice, p_mat::Array{Float64,2})\n\nCompute the run length for a given control limit using bootstraping instead of a theoretical in-control distribution.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions. This has to be a range to be compatible with arl_sop() which uses threading and multi-processing.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\np_mat::Array{Float64,2}: A matrix with the values of the relative frequencies of each d1-d2 (delay) combination. This matrix will be used for re-sampling.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(lam, cl, reps_range, chart_choice, p_array::Array{Float64,3})\n\nCompute the EWMA-BP-SOP run length for a given control limit using bootstraping instead of a theoretical in-control distribution.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\np_array::Array{Float64,3}: A 3D array with the with the relative frequencies for each d1-d2 (delay) combination. The first dimension (rows) is the picture, the second dimension refers to the patterns group (s₁, s₂, or s₃) and the third dimension denotes each d₁-d₂ combination. This array will be used for re-sampling.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop(\n\nlam, cl, lookuparraysop, preps, spatialdgp::SpatialDGP, disterror::UnivariateDistribution, distao::Union{Nothing,UnivariateDistribution}, chart_choice, m, n, d1::Int, d2::Int )\nComputes the run length for a given out-of-control DGP. The input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\np_reps::UnitRange{Int}: A range of integers for the number of repetitions.\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\ndist_error::UnivariateDistribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\ndist_ao::Union{Nothing,UnivariateDistribution}: A distribution for the additive outlier.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nm::Int: An integer value for the number of rows for the final “SOP” matrix.\nn::Int: An integer value for the number of columns for the final “SOP” matrix.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂)."
  },
  {
    "objectID": "reference/arl_sop_oc.html",
    "href": "reference/arl_sop_oc.html",
    "title": "arl_sop_oc",
    "section": "",
    "text": "arl_sop_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\n arl_sop(\n\nspatialdgp::SpatialDGP, lam, cl, d1::Int, d2::Int, reps=10000; chart_choice=3 )\nCompute the average run length (ARL) for a given out-of-control spatial DGP.\nThe input parameters are:\n\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂).\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4. The default value is 3."
  },
  {
    "objectID": "reference/count_mv_op.html",
    "href": "reference/count_mv_op.html",
    "title": "count_mv_op",
    "section": "",
    "text": "count_mv_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\ncount_mv_op(tsx, tsy; op_length::Int=3, d=1)\n\nCount the number of ordinal patterns in bins for two time series tsx and tsy. The output will be used to compute the ordinal pattern dependence coefficient by Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706.\n\ntsx: First time series for which the ordinal patterns are counted.\ntsy: Second time series for which the ordinal patterns are counted.\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\ntsx = rand(100)\ntsy = rand(100)\ncount_mv_op(tsx, tsy; op_length=3, d=1)"
  },
  {
    "objectID": "reference/arl_sop.html",
    "href": "reference/arl_sop.html",
    "title": "arl_sop",
    "section": "",
    "text": "arl_sop\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(lam, cl, sop_dgp::ICSP, d1::Int, d2::Int, reps=10_000; chart_choice=3)\n\nCompute the average run length (ARL) for a given in-control spatial DGP.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nsop_dgp::ICSP: A struct for the in-control spatial DGP.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂).\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4. The default value is 3.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(lam, cl, p_mat::Array{Float64,2}, reps=10_000)\n\nCompute the average run length (ARL) using a bootstrap approach for a particular delay (d₁-d₂) combination.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\np_mat::Array{Float64,2}: A matrix with the relative frequencies for a particular delay (d₁-d₂) combination. This matrix will be used for re-sampling. The matrix has to be computed by compute_p_array().\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop(lam, cl, p_array::Array{Float64,3}, reps=10_000; chart_choice=3)\n\nCompute the average run length for the BP-EWMA-SOP for a given control limit using bootstraping instead of a theoretical in-control distribution.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\np_array::Array{Float64, 3}: A 3D array with the with the relative frequencies of each d1-d2 (delay) combination. The first dimension (rows) is the picture, the second dimension refers to the patterns group (s₁, s₂, or s₃) and the third dimension denotes each d₁-d₂ combination. This matrix will be used for re-sampling.\nreps::Int: An integer value for the number of repetitions.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\n arl_sop(\n\nlam, cl, spatialdgp::SpatialDGP, d1::Int, d2::Int, reps=10000; chart_choice=3 )\nCompute the average run length (ARL) for a given out-of-control spatial DGP.\nThe input parameters are:\n\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂).\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4. The default value is 3.",
    "crumbs": [
      "API",
      "Functions for spatial ordinal patterns",
      "arl_sop"
    ]
  },
  {
    "objectID": "reference/arl_sacf_oc.html",
    "href": "reference/arl_sacf_oc.html",
    "title": "arl_sacf_oc",
    "section": "",
    "text": "arl_sacf_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sacf_oc(sp_dgp::SpatialDGP, lam, cl, d1::Int, d2::Int, reps=10_000)\n\nCompute the in-control average run length (ARL) using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination and an out-of-control process.\nThe input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nsp_dgp: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\nreps: The number of repetitions to compute the ARL."
  },
  {
    "objectID": "reference/cl_acf.html",
    "href": "reference/cl_acf.html",
    "title": "cl_acf",
    "section": "",
    "text": "cl_acf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\nclacf(lam, L0, acfdgp, clinit, preps=10000; jmin=4, jmax=6, verbose=false)\nFunction to compute the control limit for the ACF statistic by XXX.\n\nlam::Float64: Smoothing parameter for the EWMA statistic.\nL0::Float64: In-control ARL.\nacf_dgp::Union{IC, AR1, TEAR1}: DGP.\ncl_init::Float64: Initial guess for the control limit.\np_reps::Int64: Number of replications.\njmin::Int64: Minimum number of iterations.\n\n\n# Compute initial values via quantiles\n\ncl_acf(0.1, 3.0, IC(Normal(0, 1)), cl_init, 10000)"
  },
  {
    "objectID": "reference/rl_sacf_ic.html",
    "href": "reference/rl_sacf_ic.html",
    "title": "rl_sacf_ic",
    "section": "",
    "text": "rl_sacf_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf_ic(\nspatial_dgp::ICSP, lam, cl, d1::Int, d2::Int, p_reps::UnitRange, dist_error::UnivariateDistribution\n\n)\nCompute the in-control run length using the spatial autocorrelation function (SACF) for a delay (d1, d2) combination. The function returns the run length for a given control limit cl.\nThe input arguments are:\n\nspatial_dgp::ICSP: The in-control spatial data generating process (DGP) to use for the SACF function.\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\np_reps::UnitRange: The number of repetitions to compute the run length.\ndist_error::UnivariateDistribution: The distribution to use for the error term."
  },
  {
    "objectID": "reference/BinomialC.html",
    "href": "reference/BinomialC.html",
    "title": "BinomialC",
    "section": "",
    "text": "BinomialC\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nBinomialC{T &lt;: Real}  &lt;: DiscreteUnivariateDistribution\n\nA struct to define a binomial distribution, which gets multiplied by a constant c.\n`julia-repl dist = BinomialC(0.5, 2) rand(dist)``"
  },
  {
    "objectID": "reference/rl_sacf_bp_ic.html",
    "href": "reference/rl_sacf_bp_ic.html",
    "title": "rl_sacf_bp_ic",
    "section": "",
    "text": "rl_sacf_bp_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf_bp_ic(\n\nlam, cl, spdgp::ICSP, d1vec::Vector{Int}, d2vec::Vector{Int}, preps::UnitRange, dist_error::UnivariateDistribution )\nCompute the out-of-control run length using the spatial autocorrelation function (SACF) for the BP-statistic. The function returns the run length for a given control limit cl and a given number of repetitions reps. The input arguments are:\n\nsp_dgp::ICSP: The in-control spatial data generating process (DGP) to use for the SACF function.\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nd1_vec::Vector{Int}: The first (row) delays for the spatial process.\nd2_vec::Vector{Int}: The second (column) delays for the spatial process.\np_reps::UnitRange: The number of repetitions to compute the run length. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\ndist_error::UnivariateDistribution: The distribution to use for the error term in the spatial process. This can be any univariate distribution from the Distributions.jl package."
  },
  {
    "objectID": "reference/ICTS.html",
    "href": "reference/ICTS.html",
    "title": "ICTS",
    "section": "",
    "text": "ICTS\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nIC(dist::UnivariateDistribution)\n\nA struct to define the in-control (IC) process. The struct contains one field, namely dist::UnivariateDistribution, which is the distribution of the in-control process.\n\nic = IC(Normal(0, 1))"
  },
  {
    "objectID": "reference/rl_sop_bp_oc.html",
    "href": "reference/rl_sop_bp_oc.html",
    "title": "rl_sop_bp_oc",
    "section": "",
    "text": "rl_sop_bp_oc\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bp_oc(\nspatial_dgp::SpatialDGP, lam, cl, w::Int, lookup_array_sop, p_reps::UnitRange,\ndist_error::UnivariateDistribution, dist_ao::Union{Nothing,UnivariateDistribution}, chart_choice\n\n)\nComputes the run length for a given out-of-control DGP, using the EWMA-BP-SOP statistic.\nThe input parameters are:\n\nspatial_dgp::SpatialDGP: A struct for the out-of-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nw::Int: An integer value for the window size for the BP-statistic.\nlookup_array_sop::Array{Int, 2}: A 2D array with the lookup table for the SOPs.\np_reps::UnitRange: A range of integers for the number of repetitions.\ndist_error::UnivariateDistribution: A distribution for the error term.\ndist_ao::Union{Nothing,UnivariateDistribution}: A distribution for the additive outlier.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4."
  },
  {
    "objectID": "reference/TEAR1.html",
    "href": "reference/TEAR1.html",
    "title": "TEAR1",
    "section": "",
    "text": "TEAR1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nTEAR1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define a TEAR(1) process:\n\\(\\qquad X_t = B_t^{(\\alpha)} \\cdot X_{t-1}+(1-\\alpha) \\cdot \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\ntear1 = TEAR1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "TEAR1"
    ]
  },
  {
    "objectID": "reference/SQMA11.html",
    "href": "reference/SQMA11.html",
    "title": "SQMA11",
    "section": "",
    "text": "SQMA11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSQMA11(dgp_params, eps_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a Spatial quadratic moving-average (SQMA(1, 1)):\n\\(\\qquad  Y_{t_1, t_2}=\\beta_1 \\cdot \\varepsilon_{t_1-1, t_2}^a+\\beta_2 \\cdot \\varepsilon_{t_1, t_2-1}^b+\\beta_3 \\cdot \\varepsilon_{t_1-1, t_2-1}^c+\\varepsilon_{t_1, t_2}\\)\n\ndgp_params::Tuple(β₁::Float64, β₂::Float64, β₃::Float64): A tuple of the parameters of the DGP. The first element is the parameter β₁, the second element is the parameter β₂, and the third element is the parameter β₃.\neps_params::Tuple(a::Int, b::Int, c::Int): A tuple of the parameters of the DGP, indicating which error terms shall be squared. Note that eps_params ∈ {1, 2}.\nM_rows::Int: The number of rows for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals m + 1.\nN_cols::Int: The number of columns for the final “SOP” matrix. Note that the final spatial matrix (“picture”) equals n + 1.\ndist::Distribution A distribution for . You can use any univariate distribution from the Distributions.jl package.\ndist_ao::Nothing.\n\n\nsqma11 = SQMA11((0.5, 0.3, 0.2), (1, 1, 2), 10, 10, Normal(0,1), nothing, 1)",
    "crumbs": [
      "API",
      "Types for spatial ordinal patterns",
      "SQMA11"
    ]
  },
  {
    "objectID": "reference/stat_sacf_bp.html",
    "href": "reference/stat_sacf_bp.html",
    "title": "stat_sacf_bp",
    "section": "",
    "text": "stat_sacf_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nstat_sacf_bp(\n\ndata::Union{SubArray,Matrix{T}}, d1vec::Vector{Int}, d2vec::Vector{Int} ) where {T&lt;:Real}\nCompute the BP-spatial autocorrelation function (BP-SACF) for multiple delay combinations (d1, d2) for a single picture.\n\ndata: The data matrix.\nd1_vec::Vector{Int}: The vector of first (row) delays for the spatial process.\nd2_vec::Vector{Int}: The vector of second (column) delays for the spatial process.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nstat_sacf_bp(lam, data::Array{T,3}, d1_vec::Vector{Int}, d2_vec::Vector{Int}) where {T&lt;:Real}\n\nCompute the EWMA-BP-spatial autocorrelation function (EWMA-BP-SACF) for multiple images.\n\nlam: The smoothing parameter for the SACF.\ndata: The data matrix.\nd1_vec::Vector{Int}: The vector of first (row) delays for the spatial process.\nd2_vec::Vector{Int}: The vector of second (column) delays for the spatial process."
  },
  {
    "objectID": "reference/rl_sop_bp_ic.html",
    "href": "reference/rl_sop_bp_ic.html",
    "title": "rl_sop_bp_ic",
    "section": "",
    "text": "rl_sop_bp_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sop_bp_ic(\n\nspatialdgp::ICSP, lam, cl, lookuparraysop, repsrange, dist, chartchoice, d1vec::Vector{Int}, d2_vec::Vector{Int} )\nComputes the run length for a given in-control spatial DGP, using the EWMA-BP-SOP statistic.\nThe input parameters are:\n\nspatial_dgp::ICSP: A struct for the in-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nlookup_array_sop::Array{Int, 4}: A 4D array with the lookup array for the sops, which will be computed computed using lookup_array_sop = compute_lookup_array_sop().\nreps_range::UnitRange{Int}: A range of integers for the number of repetitions.\ndist::Distribution: A distribution for the error term. Here you can use any univariate distribution from the Distributions.jl package.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4.\nd1_vec::Vector{Int}: A vector with integer values for the first delay (d₁).\nd2_vec::Vector{Int}: A vector with integer values for the second delay (d₂)."
  },
  {
    "objectID": "reference/stat_sacf.html",
    "href": "reference/stat_sacf.html",
    "title": "stat_sacf",
    "section": "",
    "text": "stat_sacf\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nstat_sacf(data::Union{SubArray,Matrix{T}}, d1::Int, d2::Int) where {T&lt;:Real}\n\nCompute the spatial autocorrelation for a delay combination (d1, d2) for a single picture.\n\ndata: The data matrix.\nd1::Int: The first (row) delay for the spatial process.\nd2::Int: The second (column) delay for the spatial process.\n\n\n\n\n\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nstat_sacf(lam, data::Array{T,3}, d1::Int, d2::Int) where {T&lt;:Real}\n\nCompute the spatial autocorrelation function (SACF) for a delay combination (d1, d2) for multiple images.\n\nlam: The smoothing parameter for the SACF.\ndata: The data matrix.\nd1::Int: The first (row) delay for the spatial process."
  },
  {
    "objectID": "reference/rl_sacf_bp.html",
    "href": "reference/rl_sacf_bp.html",
    "title": "rl_sacf_bp",
    "section": "",
    "text": "rl_sacf_bp\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nrl_sacf_bp(\n\nlam, cl, d1vec::Vector{Int}, d2vec::Vector{Int}, preps::UnitRange, spatialdgp::SpatialDGP, disterror::UnivariateDistribution, distao::Union{UnivariateDistribution,Nothing} )\nCompute the out-of-control run length using the spatial autocorrelation function (SACF) for the BP-statistic. The function returns the run length for a given control limit cl and a given number of repetitions reps. The input arguments are:\n\nlam: The smoothing parameter for the exponentially weighted moving average (EWMA) control chart.\ncl: The control limit for the EWMA control chart.\nw::Int: The window size for the BP-statistic.’\np_reps::UnitRange: The number of repetitions to compute the run length. This has to be a unit range of integers to allow for parallel processing, since the function is called by arl_sacf().\nspatial_dgp::SpatialDGP: The spatial data generating process (DGP) to use for the SACF function. This can be one of the following: SAR1, SAR11, SAR22, SINAR11, SQMA11, SQINMA11, or BSQMA11.\ndist_error::UnivariateDistribution: The distribution to use for the error term in the spatial process. This can be any univariate distribution from the Distributions.jl package.\ndist_ao::Union{UnivariateDistribution,Nothing}: The distribution to use for the additive outlier term in the spatial process. This can be any univariate , distribution from the Distributions.jl package or Nothing."
  },
  {
    "objectID": "reference/sacf_11.html",
    "href": "reference/sacf_11.html",
    "title": "sacf_11",
    "section": "",
    "text": "sacf_11\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nsacf_11(data, cdata, cx_t_cx_t1, cdata_sq)\n\nCompute the spatial autocorrelation function (SACF) for a given matrix data. The function returns the SACF for the first lag (ρ(1, 1)). The input arguments are:\n\ndata: A matrix of size M x N.\ncdata: A matrix of size M x N to store the demeaned data.\ncx_t_cx_t1: A matrix of size M x N to store the element-wise multiplication of the current and lagged data."
  },
  {
    "objectID": "reference/ICSP.html",
    "href": "reference/ICSP.html",
    "title": "ICSP",
    "section": "",
    "text": "ICSP\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nICSP(M_rows, N_cols, dist)\n\nA struct to define an independent and identically distributed (IID) process for in-control\n\nM_rows::Int: The number of rows for the image.\nN_cols::Int: The number of columns for image.\ndist::UnivariateDistribution: A distribution from the Distributions.jl package."
  },
  {
    "objectID": "reference/SAR22.html",
    "href": "reference/SAR22.html",
    "title": "SAR22",
    "section": "",
    "text": "SAR22\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nSAR22(dgp_params, M_rows, N_cols, dist, dist_ao, prerun)\n\nA struct to define a first-order spatial autoregressive (SAR(1, 1)) process:\n\\(\\qquad \\qquad Y_{t_1, t_2} =                \\alpha_1 \\cdot Y_{t_1-1, t_2}              + \\alpha_2 \\cdot Y_{t_1,   t_2-1}              + \\alpha_3 \\cdot Y_{t_1-1, t_2-1}              + \\alpha_4 \\cdot Y_{t_1-2, t_2}              + \\alpha_5 \\cdot Y_{t_1,   t_2-2}              + \\alpha_6 \\cdot Y_{t_1-2, t_2-1}              + \\alpha_7 \\cdot Y_{t_1-1, t_2-2}              + \\alpha_8 \\cdot Y_{t_1-2, t_2-2}              + \\varepsilon_{t_1, t_2}.\\)\n\n        Yₜ₁ = α₁ ⋅ Yₜ₁₋₁ + \n              α₂ ⋅ Yₜ₁,ₜ₂₋₁ + \n              α₃ ⋅ Yₜ₁₋₁,ₜ₂₋₁ + \n              α₄ ⋅ Yₜ₁₋₂,ₜ₂ + \n              α₅ ⋅ Yₜ₁,ₜ₂₋₂ + \n              α₆ ⋅ Yₜ₁₋₂,ₜ₂₋₁ + \n              α₇ ⋅ Yₜ₁₋₁,ₜ₂₋₂ + \n              α₈ ⋅ Yₜ₁₋₂,ₜ₂₋₂ + \n              εₜ₁,ₜ₂"
  },
  {
    "objectID": "reference/changepoint_op.html",
    "href": "reference/changepoint_op.html",
    "title": "changepoint_op",
    "section": "",
    "text": "changepoint_op\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nchangepoint_op(tsx, tsy; conf_level=0.95, weight=true, bn=log(length(tsx)), op_length::Int=3, d=1)\n\nCompute the changepoint in dependence between two time series based on Schnurr and Dehling (2017) doi:10.1080/01621459.2016.1164706.\n\ntsx: First time series for which the ordinal patterns are counted.\ntsy: Second time series for which the ordinal patterns are counted.\nconf_level::Float64=0.95: Confidence level for the changepoint detection. Default is 0.95.\nweight::Bool=true: Whether to use a weight function. Default is true.\nbn::Float64=log(length(tsx)): Bandwidth for the kernel function. Default is log(length(tsx)).\nop_length::Int=3: Length of the ordinal patterns. Default is 3. Minimum is 2, maximum is 4.\nd::Int=1: Time delay. Default is 1.\n\n\ntsx = rand(100)\ntsy = rand(100)\nchangepoint_op(tsx, tsy; conf_level=0.95, weight=true, bn=log(length(tsx)), op_length=3, d=1)"
  },
  {
    "objectID": "reference/MA1.html",
    "href": "reference/MA1.html",
    "title": "MA1",
    "section": "",
    "text": "MA1\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nMA1(α::Float64, dist::UnivariateDistribution)\n\nA struct to define an MA(1) process:\n\\(\\qquad X_t = α  \\cdot \\epsilon_{t-1} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nma1 = MA1(0.5, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "MA1"
    ]
  },
  {
    "objectID": "reference/arl_sop_ic.html",
    "href": "reference/arl_sop_ic.html",
    "title": "arl_sop_ic",
    "section": "",
    "text": "arl_sop_ic\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\narl_sop_ic(sop_dgp::ICSP, lam, cl, d1::Int, d2::Int, reps=10_000; chart_choice=3)\n\nCompute the average run length (ARL) for a given in-control spatial DGP.\nThe input parameters are:\n\nsop_dgp::ICSP: A struct for the in-control spatial DGP.\nlam::Float64: A scalar value for lambda for the EWMA chart.\ncl::Float64: A scalar value for the control limit.\nd1::Int: An integer value for the first delay (d₁).\nd2::Int: An integer value for the second delay (d₂).\nreps::Int: An integer value for the number of repetitions. The default value is 10,000.\nchart_choice::Int: An integer value for the chart choice. The options are 1-4. The default value is 3."
  },
  {
    "objectID": "reference/MA2.html",
    "href": "reference/MA2.html",
    "title": "MA2",
    "section": "",
    "text": "MA2\n\n\n\n\n\n\ndocblock\n\n\n\n\n\n\nMA2(α₁::Float64, α₂::Float64, dist::UnivariateDistribution)\n\nA struct to define an MA(2) process:\n\\(\\qquad X_t = α₁  \\cdot \\epsilon_{t-1} + α₂  \\cdot \\epsilon_{t-2} + \\epsilon_t.\\)\ndist specifies the distribution of \\(\\epsilon\\) using Distributions.jl.\n\nma2 = MA2(0.5, 0.3, Normal(0, 1))",
    "crumbs": [
      "API",
      "Types for ordinal patterns",
      "MA2"
    ]
  }
]